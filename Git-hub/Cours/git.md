

Git

https://d1yei2z3i6k35z.cloudfront.net/3653488/6506fe515a4cf_0git-intro_pp.mp4

Initialiser et cloner un repo

Initialiser un repo
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6507030fe873c_lookforthebarenecessities.pn
    Que veut dire -- bare ?

    bare est un mot anglais qui signifie “nu, dépouillé, simple, brut”.



    Il en faut peu pour être heureux
    La chanson originale disney du livre de la jungle, c’était “look for the bare necessities”: il y avait un jeu de mot parce que “bare”, c’est très proche de “bear” (un ours).





    En informatique, on parle souvent de servers “bare metal”:

    ce sont des servers qui n’ont aucun software installés dessus.

    Ni Windows, ni Linux, ni rien.



    Il n’y a que le matériel (le “metal”).

    (tapez “bare metal” dans google et les résultats parleront directement de ce concept informatique).





    Pour ce qui nous concerne, un repo git “bare”,

    c’est un repo avec les fonctionnalités “minimales” ;)



    C’est un repo qui ne sert qu’à “pusher” et à “puller” du code, pas à développer dessus.



    Comme on est en train de créer en local un repo

    qui sert à faire semblant d’être sur internet, c’est parfait pour nous :)

    Cloner un repo:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/65070226bed98_2initialiserunrepo_pp.mp4
Suivre des fichiers avec git

-

add, rm et .gitignore

git add
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650707562e83c_3gitadd_pp.mp4
    git rm
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650708786e89f_4gitrm_pp.mp4
    le fichier .gitignore
    https://d1yei2z3i6k35z.cloudfront.net/3653488/65070a7b539b2_5.gitignore_pp.mp4

Faire un commit

Le principe du commit
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650711377b73c_6commitwithinsert_pp.mp4

    Le message de commit

    et les logs:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650713fd6469e_7commitmessageetlogs_pp.mp4

"Pusher" son code sur le repo distant

et le récupérer depuis un autre PC
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650eb8512b6c6_8pushpull_pp.mp4

Créer un compte Github
Ce mini-tuto texte est à destination de ceux qui n'ont pas encore de compte Github.

Si vous en avez déjà un, vous pouvez passer à la suite ;)





Pour les autres, je vous ai réalisé un tutorial texte pour cette partie parce que c'est plus facile à suivre que de devoir mettre la vidéo en pause pour faire les mêmes étapes que moi au même moment.



Allez sur Github et cliquez sur "Sign up":
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650c50dce8516_github_0.jpg
        Note: ce screenshot et les suivants peuvent avoir évolué quand vous verrez le tuto. Mais vous devriez retrouver le formulaire d'inscription dans tous les cas :)



    Vous allez tomber sur un formulaire comme celui-ci:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650c519530401_github_1.jpg
    Remplissez l'ensemble des champs puis la vérification:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650c529273269_github_2.jpg
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650c529273269_github_2.jpg
    Vous pouvez remplir l'étape de personnalisation ou la passer

    https://d1yei2z3i6k35z.cloudfront.net/3653488/650c542b9d220_github_3.jpg
    Choisissez le plan gratuit:

    https://d1yei2z3i6k35z.cloudfront.net/3653488/650c54d45be3d_github_4.jpg

    Félicitations, vous êtes inscrits !

    Vous devriez avoir accès à un dashboard comme celui-ci:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/650c55ab3cf54_github_5.jpg

Créer un repository sur Github
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6511f3e3cae76_1crerunreposurgithub_pp.mp4
    Créer un repository sur Github, c'est simple :)



    1) Allez sur https://github.com/new

    2) Renseignez les champs essentiels (le nom du repo)

    3) Ajoutez un ReadMe

    4) Cliquez sur "Create Repository"



    Voilà, vous avez un repo :)



    Note: Je vous conseille de laisser votre repo en privé dans un premier temps. On commence souvent beaucoup de choses qu'on ne termine pas, ça évite d'avoir un profil github pollué avec plein de projets commencés et jamais terminés.

    Vous passerez vos repos en public quand vous aurez produit un projet dont vous êtes fiers :)

Le fichier Readme

    https://d1yei2z3i6k35z.cloudfront.net/3653488/6511f556a0556_2lefichierreadme_pp.mp4
    Le fichier ReadMe sert à:



    1) Présenter le projet

    2) Expliciter comment télécharger et installer le projet

    3) Documenter le code

    4) Donner des "crédits" (= remercier les contributeurs clés)

    5) Préciser la license

    etc, etc...



    Le plus souvent, c'est un fichier .md (MarkDown, dont la syntaxe permet de facilement faire des titres, des listes, insérer des images...)


Le mode sombre sur Github
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6511f6a4403bc_3_bonusmode_sombre_pp.mp4
    Le fichier ReadMe sert à:



    1) Présenter le projet

    2) Expliciter comment télécharger et installer le projet

    3) Documenter le code

    4) Donner des "crédits" (= remercier les contributeurs clés)

    5) Préciser la license

    etc, etc...



    Le plus souvent, c'est un fichier .md (MarkDown, dont la syntaxe permet de facilement faire des titres, des listes, insérer des images...)
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6511f710c3203_4rcuprerlecodeenlocallesoptions_pp.mp4
    Pour récupérer le code en local, il y a plein d'options: HTTPS, personnal access token, SSH...



    Quand j'ai fait un sondage sur Linkedin avant de rédiger mon guide gratuit sur Git, l'écrasante majorité des réponses s'est portée sur SSH comme étant la méthode de choix pour se connecter dans la plupart des entreprises.



    On va donc voir ensemble ce que sont les clés privés et publiques SSH:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6511f7b050a08_5prsentationduconceptdeclssh_pp.mp4
    Les clés SSH sont donc des "mots de passes" stockés dans des fichiers situés par défaut dans le dossier ~/.ssh (situé dans votre répertoire personnel).



    On génère ces clés avec la commande ssh-keygen, qui produit deux fichiers:

    - le fichier id_rsa (clé privée)

    - le fichier id_rsa.pub (clé publique).



    Comment faire pour utiliser ces clés avec Github ? On va voir ça dans la vidéo suivante :
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6511f88e6a0ec_6AjouteruneclSSHsurgithub_pp.mp4
    Les clés SSH utilisées par Github sont légèrement différentes des clés "standard" générées par défaut par la commande ssh-keygen



    Vous vous demandez surement pourquoi Github utilise des clés différentes.



    En fait, Ed25519 est plus récent, et plus efficient ! Github promeut donc simplement une bonne pratique en forçant l'utilisation de ce type de clés.



    En plus, c'est plus simple d'utilisation:

    - Générez une clé RSA (défaut avec ssh-keygen) et faites un cat ~/.ssh/id_rsa.pub

    - Faites un cat de la clé publique générée avec Ed25519



    Comme vous pouvez le constater, cette clé est beaucoup plus courte :)





    Maintenant qu'on a vu comment se connecter en SSH à Github, on va pouvoir pusher notre code depuis notre machine sur le site:


    https://d1yei2z3i6k35z.cloudfront.net/3653488/6511fac808c42_7pushsoncodesurgithub_pp.mp4

    Le lien vers le tuto git gratuit dont je parle dans l'une des vidéos :

        https://dubreu-data-formations.notion.site/Git-Scenarios-1d97799fdd534182aace0920279e8e56

Travailler en collaboration sur GitHub
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6526d722a5439_8travaillerencollaborationsurgit_pp.mp4

    Maintenant qu'on a appris à pousser son code sur un repo distant,

    dans cette vidéo on va "simuler" ensemble le fait de pousser du code depuis un ordinateur

    et le récupérer depuis un autre.



    Ce sera l'occasion de faire une révision sur l'ensemble des commandes qu'on a vues depuis le début :)



    En fin de vidéo, on découvrira que,

    quand on est plusieurs à bosser sur le même fichier, on peut avoir des "conflits"...





    Dans la vidéo qui suit, on va voir une première approche "à la mano" pour gérer les conflits:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6526d9689117e_9fairecommesivousnaviezjamaisfaitdecommitalamanot_pp.mp4


    Quand on n'est pas trop sûr de quoi faire dans cette situation,

    il ne faut pas avoir peur de manipuler les dossiers, faire des copiers-collers

    (du moment que vous sauvegardez vos avancées quelques part, il ne peut rien se passer de "grave").





    Mais évidemment, cette façon de faire n'est pas optimale.

    On peut aller plus vite en tirant parti des fonctionnalités de git !



    On va voir comment faire ça dans les vidéos suivantes :)


Récupérer le code des collègues
avant de rajouter le vôtre
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6523123a46676_10rcuprer_le_code_avant_pp.mp4
    Dans cette vidéo, j'utilise git reset --hard pour supprimer le dernier commit,

    pour revenir à l'étape précédente en procédant comme en entreprise:

    c'est à dire en récupérant d'abord le code des collègues avant d'ajouter le votre ;)





    Evidemment, vous ne pourrez pas toujours attendre que vos collègues aient fini de modifier le code

    avant de commencer à produire le vôtre.



    C'est pour ça que git dispose du concept de branches, qu'on va découvrir ensemble dans les prochaines vidéos ;)

Collaborer sur git avec les branches

    https://d1yei2z3i6k35z.cloudfront.net/3653488/6523160ce134f_11gitbranchingintroduction_pp.mp4
    Supprimer une branche

    https://d1yei2z3i6k35z.cloudfront.net/3653488/652317d52ad3a_12supprimerunebranche_pp.mp4

git branches: le fonctionnement

    https://d1yei2z3i6k35z.cloudfront.net/3653488/6523190af0587_13lefonctionnementdesbranches_pp.mp4
    "Pusher" votre branche sur github

    https://d1yei2z3i6k35z.cloudfront.net/3653488/65231afbc347b_14pushersabranchelocalesurlerepodistant_pp.mp4
    Créer et merger une pull request

    https://d1yei2z3i6k35z.cloudfront.net/3653488/65231bc91ea25_15lespullrequestssurGithub_pp.mp4
Récupérer le code des collègues
avant de rajouter le vôtre
    https://d1yei2z3i6k35z.cloudfront.net/3653488/6525027e12a03_16recap_pp.mp4
    Récapitulatif de toutes les commandes qu'on a vues jusqu'à présent.





    Pour travailler avec git en entreprise:



    -> se mettre en local sur la Main ou sur la Develop

    -> récupérer la dernière version du code (git pull)

    -> créer une branche à partir de là

    -> sur cette branche, faire vos modifications de code

    -> ajouter ces modifications à l'index

    -> faire un commit

    -> push votre branche locale sur github (1)

    -> aller sur github et créer une pull request de votre branche vers la main (ou la develop s'il y en a une)

    -> envoyer votre PR à un collègue pour qu'il vérifie le code

    -> si votre collègue accepte les modifications, merger la PR



    => Félicitations, vous avez mis à jour le code de votre entreprise !

    Note
    (1) Si vous en avez marre que git vous dise:



    "fatal: The current branch master has no upstream branch.",

    vous pouvez soit utiliser:

    "git push -u origin head"

    (mais il faudra le faire à chaque fois)

    soit, avec les dernières version de git, modifier une seule fois votre config :



    "git config --global push.autoSetupRemote true"



    et ensuite vos "git push" fonctionneront tout le temps, même quand il n'y a pas encore d'upstream branch ;)
git branches:
travailler sur le même fichier en même temps.
La situation de conflit sur Github:
    https://d1yei2z3i6k35z.cloudfront.net/3653488/65267c5ac0585_17travaillerenmemetempssurlememefichier_pp.mp4

    Résoudre les conflits via l'interface github

    (avec un merge commit)
    https://d1yei2z3i6k35z.cloudfront.net/3653488/65267d5155a65_18grerlesconflitsavecunmergecommit_pp.mp4
    Résoudre les conflits en local

    (avec un git rebase)
    https://d1yei2z3i6k35z.cloudfront.net/3653488/65267dc7309a0_19grerlesconflitsenlocalavecgitrebase_pp.mp4
    Exercices récapitulatifs
    SOLO:



    1) créez un nouveau repository sur Github

    2) clonez le en local dans un répertoire nommé "copie_du_repo_sur_mon_pc"

    3) rentrez dans le pc et créez un fichier "premier_script.py"

    4) ajoutez le à l'index

    5) commitez le fichier

    6) pushez votre commit sur le repo Github (retournez voir sur Github qu'il est bien apparu)



    ---



    COLLABORATION (avec branches, sans conflits):



    1) clonez votre repository dans un autre repertoire nommé "copie_du_repo_sur_pc_collègue"

    2) rentrez dans le dossier et créez une branche nommée "feature_collègue"

    (note: feature veut plus ou moins dire "fonctionnalité", quand on ajoute un mécanisme métier dans le code, on dit souvent qu'on ajoute une "feature")

    3) si ce n'est pas fait, positionnez-vous sur cette branche

    4) créez un fichier "second_script.py" (la totale: add, commit, push)

    5) ouvrez une Pull Request sur Github. Laissez la ouverte ! (ne mergez pas la PR !)



    5) pendant ce temps là, retournez dans le repo qui se trouve dans le dossier "copie_du_repo_sur_mon_pc"

    6) créez une branche nommée "feature_hello_world"

    7) modifiez le script "premier_script.py" en ajoutant un print("hello world") dedans

    8) add, commit, push

    9) créez une PR



    10) vous avez maintenant 2 PR ouvertes en même temps ! Que va-t-'il se passer ?



    => Mergez d'abord votre PR, puis ensuite celle de la collègue



    Comme vous pouvez le constater, en utilisant des branches, il n'y a pas de problème.

    (alors que quand on avait tenter de push un commit différent directement sur la branche principale, git refusait parce qu'il y avait déjà le commit de la collègue).







    /!\ Deuxième point d'attention /!\

    Si vous retournez sur la page principale de votre repo sur Github et que vous regardez l'historique des commits:

    https://d1yei2z3i6k35z.cloudfront.net/3653488/6527f164291ff_click_here_to_find_commits.png

    On peut voir que les commits ne sont pas dans l'ordre dans lequel ils ont été mergés.



    (j'avais fait exprès de vous demander de merger "votre branche" avant celle de votre collègue)





    => La commande git merge conserve les commits dans l'ordre (chronologique) dans lequel ils ont été écrits !



    Ce n'est pas le cas du rebase.

    On va aller plus en profondeur dans la différence entre merge et rebase dans les prochaines vidéos ;)

les hashs:
à quoi ils servent, comment ils sont créés, l'impact sur l'historique
A quoi correspondent les hash, et comment sont-ils générés ?
    https://d1yei2z3i6k35z.cloudfront.net/3653488/652800cc0211e_20hashs.mp4
    A chaque nouveau add ou commit, git stocke des nouveau objets dans son répertoire cachés.



    Ces objects contiennent soit le contenu de vos fichiers en lui même (encodé en binaire), soit des informations utiles à git pour tracer l'historique.



    Les fichiers qui contiennent ces objects ont un nom barbare (par exemple: "4774651cdef3b146ac766e724ad17e14b1db0482"), qui est obtenu en utilisant la fonction de hash SHA-1.



    Cette fonction de hash prends en paramètre le contenu du fichier.



    Ceci a une implication importante: contenu différent = hash différent ;)



    Changer le code = changer le hash des commits

    https://d1yei2z3i6k35z.cloudfront.net/3653488/652801698cfda_21impactducontenusurleshashs.mp4

    Cette vidéo propose une illustration de la conclusion de la vidéo précédente: contenu différent = hash différent.



    Même quand le commit contient les mêmes modifications par rapport à un commit précédent, si le commit précédent est différent, le nouveau commit (qui ne fait qu'ajouter un fichier vide nommé pareil) prends un hash différent.





    (Au passage, on introduit la commande git commit --amend qui permet d'éditer le commit précédent)

git merge vs. git rebase
et conclusion :)
    https://d1yei2z3i6k35z.cloudfront.net/3653488/65281f311eca0_conclusion-rebasevsmerge_pp.mp4
    Dans la vidéo, je dis qu'on a fait les 2/3 du programme. C'est une exagération. Comme j'ai délégué la partie Spark à un expert, c'est plutôt moi qui ai fini les 2/3. Vous, vous en êtes à une grosse moitié :p



    Mais c'est déjà beaucoup, donc félicitations d'être arrivés jusqu'ici.



    Récompensez-vous avec un bon carré de chocolat :)

Interview avec Fares Daoud

le "sorcier" de git
    https://streamyard.com/e/w2cy43uckzqi
    Apparemment, certains rencontrent des problèmes pour voir la vidéo dans l'interface systeme.io.

    Si c'est le cas, merci de me dire dans les commentaires ci-dessous quel OS et quel navigateur vous utilisez :)



    En attendant, vous devriez pouvoir visionner la vidéo sur ce lien :

    https://streamyard.com/watch/qFVu3nZBFPJg







    Les articles écrits par Fares sur Medium:



    https://medium.com/@david.alvares.62/git-rebase-behind-the-scenes-dd534ac8a4a4?sk=6035bc72ab2c620dcfe4c827fecb2d30

    https://medium.com/@david.alvares.62/take-some-git-magic-potion-b06bbfb39c04?sk=b23de8cc7379e10b7e9839adf41bbecc



    (faites pas attention au David Alvares, c'est son nom d'emprunt :p)

